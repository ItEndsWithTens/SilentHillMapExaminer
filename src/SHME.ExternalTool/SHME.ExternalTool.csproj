<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <LangVersion>10.0</LangVersion>
    <Nullable>enable</Nullable>
    <TargetFramework>net48</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.3" PrivateAssets="all" />
    <PackageReference Include="Microsoft.SourceLink.GitHub" Version="8.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="System.Drawing.Common" Version="7.0.0" />

    <Reference Include="BizHawk.Bizware.BizwareGL" HintPath="$(BizHawkOutputDir)\dll\BizHawk.Bizware.BizwareGL.dll" />
    <Reference Include="BizHawk.Client.Common" HintPath="$(BizHawkOutputDir)\dll\BizHawk.Client.Common.dll" />
    <Reference Include="BizHawk.Client.EmuHawk" HintPath="$(BizHawkOutputDir)\EmuHawk.exe" />
    <Reference Include="BizHawk.Common" HintPath="$(BizHawkOutputDir)\dll\BizHawk.Common.dll" />
    <Reference Include="BizHawk.Emulation.Common" HintPath="$(BizHawkOutputDir)\dll\BizHawk.Emulation.Common.dll" />
    <Reference Include="BizHawk.Emulation.Cores" HintPath="$(BizHawkOutputDir)\dll\BizHawk.Emulation.Cores.dll" />
    <Reference Include="BizHawk.Emulation.DiscSystem" HintPath="$(BizHawkOutputDir)\dll\BizHawk.Emulation.DiscSystem.dll" />
    <Reference Include="BizHawk.WinForms.Controls" HintPath="$(BizHawkOutputDir)\dll\BizHawk.WinForms.Controls.dll" />
    <Reference Include="System.Windows.Forms" />

    <ProjectReference Include="..\CustomBuildTasks\CustomBuildTasks.csproj">
      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
    </ProjectReference>
  </ItemGroup>

  <!--Node reuse by MSBuild means that after a build, an inline task using the
  BizHawk.Common assembly would keep that .dll open, preventing it from being
  replaced when attempting to e.g. recompile BizHawk at a different commit. This
  approach, using TaskHostFactory, forces the task to run in its own isolated
  process, freeing resources (a file handle, in this case) afterwards.-->
  <UsingTask
    TaskName="CustomBuildTasks.ReadBizHawkVersion"
    TaskFactory="TaskHostFactory"
    AssemblyFile="$(ArtifactsDir)/bin/CustomBuildTasks/$(Configuration)/netstandard2.0/CustomBuildTasks.dll">
  </UsingTask>

  <Target Name="SetAssemblyTitle" AfterTargets="DecideFinalVersionNumber">
    <CustomBuildTasks.ReadBizHawkVersion>
      <Output PropertyName="BizHawkVersion" TaskParameter="BHV" />
    </CustomBuildTasks.ReadBizHawkVersion>

    <PropertyGroup>
      <AssemblyTitle>$(Product) for BizHawk $(BizHawkVersion)</AssemblyTitle>
    </PropertyGroup>
  </Target>

  <Target Name="InstallInEmulator" AfterTargets="PostBuildEvent">
    <Copy SourceFiles="$(OutputPath)\$(MSBuildProjectName).dll" DestinationFolder="$(BizHawkOutputDir)\ExternalTools" />
  </Target>

  <PropertyGroup>
    <DistDir>$(ArtifactsDir)\dist\</DistDir>
    <PrepDir>$(DistDir)\prep\</PrepDir>
  </PropertyGroup>

  <!--When running the CreateZip target to produce the distribution archive,
  it's only sensible to strip local file path information out of the embedded
  debug symbols even if the build happens to be running on a developer's local
  machine. A dedicated target that CreateZip depends on handles that with,
  admittedly, some fuss.-->
  <Target Name="SetCIBuild" BeforeTargets="Build">
    <PropertyGroup>
      <!--ContinuousIntegrationBuild, when set true as a property directly in a
      project, sets DeterministicSourcePaths true as well. Unfortunately, for
      the time being updating the value of the former while in a target fails to
      also update the value of the latter. Doing it manually seems to work.-->
      <ContinuousIntegrationBuild>true</ContinuousIntegrationBuild>
      <DeterministicSourcePaths>true</DeterministicSourcePaths>
    </PropertyGroup>
  </Target>

  <Target Name="CreateZip" DependsOnTargets="SetCIBuild;Build">
    <RemoveDir Directories="$(PrepDir)" />
    <Copy SourceFiles="$(OutputPath)\$(MSBuildProjectName).dll" DestinationFolder="$(PrepDir)" />
    <Copy SourceFiles="$(TopLevelDirectory)\README.md" DestinationFiles="$(PrepDir)\$(MSBuildProjectName).txt" />
    <ZipDirectory SourceDirectory="$(PrepDir)" DestinationFile="$(DistDir)\$(MSBuildProjectName)-$(Version).zip" Overwrite="true" />
  </Target>

</Project>
